/**
 * This file is part of Key20.
 *
 * Copyright 2016 Frank Duerr
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <string.h>
#include <nrf.h>
#include <nrf_gpio.h>
#include <ble.h>
#include <softdevice_handler.h>
#include <ble_advdata.h>
#include <app_timer.h>
#include <app_button.h>
#include <curve25519-cortexm0.h>
#include <avrnacl.h>
#include <hd44780nrf51.h>
#include "app_event_queue.h"

#define PIN_BUTTON1 17
#define PIN_LED 21

// Pins connected to LCD
#define PIN_LCD_RS 16
#define PIN_LCD_E 18
#define PIN_LCD_DB4 12
#define PIN_LCD_DB5 13
#define PIN_LCD_DB6 14
#define PIN_LCD_DB7 15

// Maximum number of pending application events. 
// In order to decouple event processing from event generation often happening
// in the context of interrupts, we use an application event queue.
#define APP_EVENT_QUEUE_SIZE 16

// Application-level events.
#define APP_EVENT_CFG_TIMEOUT 0
#define APP_EVENT_BUTTON1_PRESSED 1
#define APP_EVENT_CLIENT_CONNECTED 2
#define APP_EVENT_CLIENT_SUBSCRIBED 3
#define APP_EVENT_KEY_PART1_RCVD 4
#define APP_EVENT_KEY_PART2_RCVD 5
#define APP_EVENT_HMAC_PART1_RCVD 6
#define APP_EVENT_HMAC_PART2_RCVD 7
#define APP_EVENT_ACK_RCVD 8

// Length of Diffie-Hellman keys using Eliptic Curve 25519 [bytes].
#define ECDH_KEY_LENGTH crypto_scalarmult_curve25519_BYTES

// Length of a SHAR512 [bytes].
#define SHA512_HASH_LENGTH crypto_hash_sha512_BYTES

// Length of an HMAC512-256 [bytes].
#define HMAC512_256 crypto_auth_hmacsha512256_BYTES

// Max. length of the Nonce characteristic.
#define MAX_LENGTH_NONCE_CHAR 16
 
// Max. length of Unlock characteristic [bytes].
#define MAX_LENGTH_UNLOCK_CHAR 17

// Max. length of Cfgin characteristic [bytes].
#define MAX_LENGTH_CFG_IN_CHAR 17

// Max. length of Cfgout characteristic [bytes].
#define MAX_LENGTH_CFG_OUT_CHAR 17

// Length of nonces used to avoid replay attacks [bytes].
// 128 bit nonces provide for sufficient security, assuming the following
// parameters:
// 
// 1. one request per millisecond and 100 years of operation 
//    -> less than n = 2**42 requests to protect.
//    Actually, nonces are only changed after successful authentication 
//    requests, i.e., when the door opened, so practically, we have to protect 
//    much fewer requests. Opening the door once per millisecond is highly 
//    unlikely, thus, 2**42 is a very pessimistic value.
// 2. m = 2**128 different nonces.
//
// Then the birthday paradox can be used to calculate the probability p of 
// at least one pair of requests sharing the same nonce, or, inversely,
// no nonces shared by any pair of requests. An approximation of p for n << m 
// is p(n,m) = 1 - e**((-n**2)/(2*m)), which practically evaluates to 0 for
// n = 2**42 and m = 2**128. Even for n = 2**52 (one request per us), 
// p(2**52,2**128) < 3e-8 which is about the probability to be hit by 
// lightning (about 5.5e-8).
// A nonce of 16 bytes also fits nicely into a BLE characteristic.
#define NONCE_LENGTH 16

#define DEVICE_NAME "Key20"
// Minimum connection interval in 1.25 ms. Minimum allowed value: 7.5 ms.
// 16 -> 20 ms.
#define MIN_CONN_INTERVAL 16
// Maximum connection interval in 1.25 ms. Maximum allowed value: 4000 ms.
// 100 -> 125 ms.
#define MAX_CONN_INTERVAL 100
// Number of connection intervals the device can stay silent.
#define SLAVE_LATENCY 2
// Connection supervision timeout, i.e., time until a link is considered
// lost, in 10 ms.
// 400 -> 4 s. 
#define CONN_SUP_TIMEOUT 400
// Advertisement interval in 0.625 ms; min. 20 ms, max 10.24 s.
// 64 -> 40 ms.
#define ADV_INTERVAL 64
// How long to advertise in seconds (0 = forever)
#define ADV_TIMEOUT 0

// Prescaler of RTC1 (low-frequency clock at 32.768 kHz), which is used by the 
// app timer (RTC0 is used by the softdevice, and, therefore, cannot be used by 
// the application). 
#define APP_TIMER_PRESCALER 0
#define APP_TIMER_QUEUE_SIZE 6

// Delay for debouncing buttons [ms].
#define BUTTON_DETECTION_DELAY APP_TIMER_TICKS(50, APP_TIMER_PRESCALER)

// Delay of configuration timer [ms].
#define CONFIG_TIMER_TIMEOUT APP_TIMER_TICKS(30000, APP_TIMER_PRESCALER)

// Service and charateristic UUIDs in Little Endian format.
// The 16 bit values will become byte 12 and 13 of the 128 bit UUID:
// 0x0cddxxxx-df68-4777-8d2e-52fa8ad22820
#define UUID_BASE {0xaf, 0x1f, 0xcf, 0xe7, 0x7d, 0x62, 0x53, 0x8a, \
	           0x58, 0x4c, 0xf4, 0x5f, 0x00, 0x00, 0x9d, 0x0a}
#define UUID_SERVICE 0x0001
#define UUID_CHARACTERISTIC_NONCE 0x0002
#define UUID_CHARACTERISTIC_UNLOCK 0x0003
#define UUID_CHARACTERISTIC_CFG_IN 0x0004
#define UUID_CHARACTERISTIC_CFG_OUT 0x0004

// Application states.
enum app_states {idle, cfg_wait_connection, cfg_wait_subscription, 
		 cfg_wait_key_part1, cfg_wait_key_part2, cfg_wait_ack, 
		 cfg_wait_confirmation, wait_hmac_part1, wait_hmac_part2} ;

enum app_states app_state = idle;

// Definition of the connected LCD. 
struct hd44780 lcd = {
      .pin_rs = PIN_LCD_RS, 
      .pin_e = PIN_LCD_E, 
      .pin_db4 = PIN_LCD_DB4, 
      .pin_db5 = PIN_LCD_DB5, 
      .pin_db6 = PIN_LCD_DB6,
      .pin_db7 = PIN_LCD_DB7, 
      .rows = 2,
      .columns = 16
};

APP_TIMER_DEF(config_timer);

uint8_t uuid_type;
uint16_t service_handle;
ble_gatts_char_handles_t char_handle_nonce;
ble_gatts_char_handles_t char_handle_unlock;
ble_gatts_char_handles_t char_handle_cfg_in;
ble_gatts_char_handles_t char_handle_cfg_out;
uint16_t conn_handle = BLE_CONN_HANDLE_INVALID; 

uint8_t nonce[NONCE_LENGTH];

bool is_config_timer_active = true;

struct app_event_queue app_event_queue;

static void display_text(const char *text1, unsigned int length1,
			 const char *text2, unsigned int length2);

static void init_app_event_queue()
{
     app_event_queue_init(&app_event_queue, APP_EVENT_QUEUE_SIZE);
}

static void led_off()
{
     // LED is active low -> set to turn off.
     nrf_gpio_pin_set(PIN_LED);
}

static void led_on()
{
     // LED is active low -> clear to turn on.
     nrf_gpio_pin_clear(PIN_LED);
}

static void die()
{
     display_text("Error", 5, NULL, 0);

     while (1);
}

static void led_init()
{
     nrf_gpio_cfg_output(PIN_LED);
     led_off();
}

static void start_advertising()
{
    uint32_t err_code;
    ble_gap_adv_params_t adv_params;

    memset(&adv_params, 0, sizeof(adv_params));
    adv_params.type = BLE_GAP_ADV_TYPE_ADV_IND;
    adv_params.p_peer_addr = NULL;
    adv_params.fp = BLE_GAP_ADV_FP_ANY;
    adv_params.interval = ADV_INTERVAL;
    adv_params.timeout = ADV_TIMEOUT;

    err_code = sd_ble_gap_adv_start(&adv_params);
    if (err_code != NRF_SUCCESS)
	 die();
}

static void ble_evt_handler(ble_evt_t *ble_evt)
{
     ble_gatts_evt_write_t *evt_write;
     uint8_t char_data;

     switch (ble_evt->header.evt_id) {
     case BLE_GAP_EVT_CONNECTED:
	  conn_handle = ble_evt->evt.gap_evt.conn_handle;
	  break;
     case BLE_GAP_EVT_DISCONNECTED:
	  conn_handle = BLE_CONN_HANDLE_INVALID;
	  start_advertising();
	  break;
     case BLE_GAP_EVT_SEC_PARAMS_REQUEST:
	  // Pairing not supported
	  sd_ble_gap_sec_params_reply(conn_handle, 
				      BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP,
				      NULL, NULL);
	  break;
     case BLE_GATTS_EVT_WRITE:
          evt_write = &ble_evt->evt.gatts_evt.params.write;
	  if (evt_write->handle == char_handle_nonce.value_handle && 
	      evt_write->len == 1) {
	       // Our charateristic value is a simple byte
	       char_data = evt_write->data[0];
	       // TODO: do something with this byte
	  }
	  break;
     case BLE_GATTS_EVT_SYS_ATTR_MISSING:
	  // No system attributes have been stored.
	  sd_ble_gatts_sys_attr_set(conn_handle, NULL, 0, 0);
	  break;
    }
}

static void ble_stack_init()
{
     uint32_t err_code;

     // The softdevice uses RTC0 (32 kHz real-time clock) for timing.
     // We use an external crystal with 20 ppm accuracy.
     SOFTDEVICE_HANDLER_INIT(NRF_CLOCK_LFCLKSRC_XTAL_20_PPM, false);

     // Enable BLE stack 
     ble_enable_params_t ble_enable_params;
     memset(&ble_enable_params, 0, sizeof(ble_enable_params));
     err_code = sd_ble_enable(&ble_enable_params);
     if (err_code != NRF_SUCCESS)
	  die();
     
     // Set Bluetooth address?
     ble_gap_addr_t addr;
     err_code = sd_ble_gap_address_get(&addr);
     APP_ERROR_CHECK(err_code);
     err_code = sd_ble_gap_address_set(BLE_GAP_ADDR_CYCLE_MODE_NONE, &addr);
     if (err_code != NRF_SUCCESS)
	  die();
     
     // Subscribe for BLE events.
     err_code = softdevice_ble_evt_handler_set(ble_evt_handler);
     if (err_code != NRF_SUCCESS)
	  die();
}

static void gap_init()
{
     uint32_t err_code;
     ble_gap_conn_params_t gap_conn_params;
     ble_gap_conn_sec_mode_t sec_mode;

     // Open link, no encryption required on BLE layer. 
     // Security is handled only on the application layer. 
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&sec_mode);
     
     // Set device name.
     err_code = sd_ble_gap_device_name_set(&sec_mode,
					   (const uint8_t *) DEVICE_NAME,
					   strlen(DEVICE_NAME));
     if (err_code != NRF_SUCCESS)
	  die();
     
     // Set connection parameters.
     memset(&gap_conn_params, 0, sizeof(gap_conn_params));
     gap_conn_params.min_conn_interval = MIN_CONN_INTERVAL;
     gap_conn_params.max_conn_interval = MAX_CONN_INTERVAL;
     gap_conn_params.slave_latency = SLAVE_LATENCY;
     gap_conn_params.conn_sup_timeout = CONN_SUP_TIMEOUT;     
     err_code = sd_ble_gap_ppcp_set(&gap_conn_params);
     if (err_code != NRF_SUCCESS)
	  die();
}

static void add_characteristic_nonce(uint16_t service_handle)
{
     // Characteristic UUID.
     ble_uuid_t ble_uuid;
     ble_uuid.type = uuid_type;
     ble_uuid.uuid = UUID_CHARACTERISTIC_NONCE;

     // Define characteristic presentation format.
     // The nonce is a 16 byte number, which is declared as opaque struct.
     ble_gatts_char_pf_t char_presentation_format;
     memset(&char_presentation_format, 0, sizeof(char_presentation_format));
     char_presentation_format.format = BLE_GATT_CPF_FORMAT_STRUCT;
     char_presentation_format.exponent = 0;
     char_presentation_format.unit = 0x2700; // unitless

     // Define characteristic meta data.
     // The nonce is only readable.
     ble_gatts_char_md_t char_meta_data;
     memset(&char_meta_data, 0, sizeof(char_meta_data));
     char_meta_data.char_props.read = 1;
     char_meta_data.char_props.write = 0;
     char_meta_data.char_props.notify = 0;
     char_meta_data.char_props.indicate = 0;
     char_meta_data.p_char_user_desc = NULL;
     char_meta_data.p_char_pf = &char_presentation_format;
     char_meta_data.p_user_desc_md = NULL;
     // CCCD (Client Characteristic Configuration Descriptor) only needs to be 
     // set for characteristics allowing for notifications and indications.
     char_meta_data.p_cccd_md = NULL;
     char_meta_data.p_sccd_md = NULL;

     // Define attribute meta data. 
     ble_gatts_attr_md_t char_attr_meta_data;
     memset(&char_attr_meta_data, 0, sizeof(char_attr_meta_data));
     // No security needed. All security implemented on the application layer.
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&char_attr_meta_data.read_perm);
     BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&char_attr_meta_data.write_perm);
     // value location
     char_attr_meta_data.vloc = BLE_GATTS_VLOC_STACK;
     // always request read authorization from application 
     char_attr_meta_data.rd_auth = 0;
     // always request write authorization from application
     char_attr_meta_data.wr_auth = 0;
     // variable length attribute
     char_attr_meta_data.vlen = 0;

     // Define characteristic attributes. 
     // Nonce is a fixed length 16 byte data structure.
     ble_gatts_attr_t char_attributes;
     memset(&char_attributes, 0, sizeof(char_attributes));
     char_attributes.p_uuid = &ble_uuid;
     char_attributes.p_attr_md = &char_attr_meta_data;
     char_attributes.init_len = MAX_LENGTH_NONCE_CHAR;
     char_attributes.init_offs = 0;
     char_attributes.max_len = MAX_LENGTH_NONCE_CHAR;
     // For attributes managed by the application (BLE_GATTS_VLOC_USER)
     // rather than the BLE stack, set a pointer to the memory location here.
     char_attributes.p_value = NULL;

     // Add characteristic to service.
     if (sd_ble_gatts_characteristic_add(service_handle,
					 &char_meta_data,
					 &char_attributes,
					 &char_handle_nonce) != NRF_SUCCESS)
	  die();

     // Set initial characteristic value.
     ble_gatts_value_t value;
     memset(&value, 0, sizeof(value));
     value.len = sizeof(nonce);
     value.offset  = 0;
     value.p_value = nonce;
     if (sd_ble_gatts_value_set(BLE_CONN_HANDLE_INVALID, 
				char_handle_nonce.value_handle, &value) != 
	 NRF_SUCCESS)
	  die();
}

static void add_characteristic_unlock(uint16_t service_handle)
{
     // Characteristic UUID.
     ble_uuid_t ble_uuid;
     ble_uuid.type = uuid_type;
     ble_uuid.uuid = UUID_CHARACTERISTIC_UNLOCK;

     // Define characteristic presentation format.
     // This characteristic transports a 256 bit HMAC to authenticate the
     // door open request. 256 bit = 32 bytes are too long for a 
     // characteristic. So we split up the request into two 16 byte write
     // operations to the characteristic. Moreover, we include the key number
     // in the request as another byte. Thus, this is a 17 byte opaque
     // struct.
     ble_gatts_char_pf_t char_presentation_format;
     memset(&char_presentation_format, 0, sizeof(char_presentation_format));
     char_presentation_format.format = BLE_GATT_CPF_FORMAT_STRUCT;
     char_presentation_format.exponent = 0;
     char_presentation_format.unit = 0x2700; // unitless

     // Define characteristic meta data.
     // The Unlock characteristic must support writing to receive authentication
     // data.
     ble_gatts_char_md_t char_meta_data;
     memset(&char_meta_data, 0, sizeof(char_meta_data));
     char_meta_data.char_props.read = 1;
     char_meta_data.char_props.write = 1;
     char_meta_data.char_props.notify = 0;
     char_meta_data.char_props.indicate = 0;
     char_meta_data.p_char_user_desc = NULL;
     char_meta_data.p_char_pf = &char_presentation_format;
     char_meta_data.p_user_desc_md = NULL;
     // CCCD (Client Characteristic Configuration Descriptor) only needs to be 
     // set for characteristics allowing for notifications and indications.
     char_meta_data.p_cccd_md = NULL;
     char_meta_data.p_sccd_md = NULL;

     // Define attribute meta data. 
     ble_gatts_attr_md_t char_attr_meta_data;
     memset(&char_attr_meta_data, 0, sizeof(char_attr_meta_data));
     // No security needed. All security implemented on the application layer.
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&char_attr_meta_data.read_perm);
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&char_attr_meta_data.write_perm);
     // value location
     char_attr_meta_data.vloc = BLE_GATTS_VLOC_STACK;
     // always request read authorization from application 
     char_attr_meta_data.rd_auth = 0;
     // always request write authorization from application
     char_attr_meta_data.wr_auth = 0;
     // variable length attribute
     char_attr_meta_data.vlen = 0;

     // Define characteristic attributes. 
     // This is a fixed length 17 byte data structure.
     ble_gatts_attr_t char_attributes;
     memset(&char_attributes, 0, sizeof(char_attributes));
     char_attributes.p_uuid = &ble_uuid;
     char_attributes.p_attr_md = &char_attr_meta_data;
     char_attributes.init_len = MAX_LENGTH_UNLOCK_CHAR;
     char_attributes.init_offs = 0;
     char_attributes.max_len = MAX_LENGTH_UNLOCK_CHAR;
     // For attributes managed by the application (BLE_GATTS_VLOC_USER)
     // rather than the BLE stack, set a pointer to the memory location here.
     char_attributes.p_value = NULL;

     // Add characteristic to service.
     if (sd_ble_gatts_characteristic_add(service_handle,
					 &char_meta_data,
					 &char_attributes,
					 &char_handle_unlock) != NRF_SUCCESS)
	  die();
}

static void add_characteristic_cfg_in(uint16_t service_handle)
{
     // Characteristic UUID.
     ble_uuid_t ble_uuid;
     ble_uuid.type = uuid_type;
     ble_uuid.uuid = UUID_CHARACTERISTIC_CFG_IN;

     // Define characteristic presentation format.
     // This characteristic transports a 32 byte public key (split into two
     // 16 byte parts due to characteristic length restrictions) for
     // key exchange, plus one byte defining the key number.
     // Thus, this is a 17 byte opaque struct.
     ble_gatts_char_pf_t char_presentation_format;
     memset(&char_presentation_format, 0, sizeof(char_presentation_format));
     char_presentation_format.format = BLE_GATT_CPF_FORMAT_STRUCT;
     char_presentation_format.exponent = 0;
     char_presentation_format.unit = 0x2700; // unitless

     // Define characteristic meta data.
     // The config-in characteristic must support writing to receive
     // configuration data.
     ble_gatts_char_md_t char_meta_data;
     memset(&char_meta_data, 0, sizeof(char_meta_data));
     char_meta_data.char_props.read = 1;
     char_meta_data.char_props.write = 1;
     char_meta_data.char_props.notify = 0;
     char_meta_data.char_props.indicate = 0;
     char_meta_data.p_char_user_desc = NULL;
     char_meta_data.p_char_pf = &char_presentation_format;
     char_meta_data.p_user_desc_md = NULL;
     // CCCD (Client Characteristic Configuration Descriptor) only needs to be 
     // set for characteristics allowing for notifications and indications.
     char_meta_data.p_cccd_md = NULL;
     char_meta_data.p_sccd_md = NULL;

     // Define attribute meta data. 
     ble_gatts_attr_md_t char_attr_meta_data;
     memset(&char_attr_meta_data, 0, sizeof(char_attr_meta_data));
     // No security needed. All security implemented on the application layer.
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&char_attr_meta_data.read_perm);
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&char_attr_meta_data.write_perm);
     // value location
     char_attr_meta_data.vloc = BLE_GATTS_VLOC_STACK;
     // always request read authorization from application 
     char_attr_meta_data.rd_auth = 0;
     // always request write authorization from application
     char_attr_meta_data.wr_auth = 0;
     // variable length attribute
     char_attr_meta_data.vlen = 0;

     // Define characteristic attributes. 
     // This is a fixed length 17 byte data structure.
     ble_gatts_attr_t char_attributes;
     memset(&char_attributes, 0, sizeof(char_attributes));
     char_attributes.p_uuid = &ble_uuid;
     char_attributes.p_attr_md = &char_attr_meta_data;
     char_attributes.init_len = MAX_LENGTH_CFG_IN_CHAR;
     char_attributes.init_offs = 0;
     char_attributes.max_len = MAX_LENGTH_CFG_IN_CHAR;
     // For attributes managed by the application (BLE_GATTS_VLOC_USER)
     // rather than the BLE stack, set a pointer to the memory location here.
     char_attributes.p_value = NULL;

     // Add characteristic to service.
     if (sd_ble_gatts_characteristic_add(service_handle,
					 &char_meta_data,
					 &char_attributes,
					 &char_handle_cfg_in) != NRF_SUCCESS)
	  die();
}

static void add_characteristic_cfg_out(uint16_t service_handle)
{
     // Characteristic UUID.
     ble_uuid_t ble_uuid;
     ble_uuid.type = uuid_type;
     ble_uuid.uuid = UUID_CHARACTERISTIC_CFG_OUT;

     // Define characteristic presentation format.
     // This characteristic transports a 32 byte public key (split into two
     // 16 byte parts due to characteristic length restrictions) for
     // key exchange, plus one byte defining the key number.
     // Thus, this is a 17 byte opaque struct.
     ble_gatts_char_pf_t char_presentation_format;
     memset(&char_presentation_format, 0, sizeof(char_presentation_format));
     char_presentation_format.format = BLE_GATT_CPF_FORMAT_STRUCT;
     char_presentation_format.exponent = 0;
     char_presentation_format.unit = 0x2700; // unitless

     // Define CCCD attributes. 
     // CCCD (Client Characteristic Configuration Descriptor) is used by the
     // client to enable notifications or indications by writing a flag to the
     // CCCD attribute.
     ble_gatts_attr_md_t cccd_meta_data;
     memset(&cccd_meta_data, 0, sizeof(cccd_meta_data));
     // CCCD must be read and writable. 
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_meta_data.read_perm);
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_meta_data.write_perm);
     cccd_meta_data.vloc = BLE_GATTS_VLOC_STACK;

     // Define characteristic meta data.
     // The config-out characteristic must suppport indications for sending
     // config data to the client.
     ble_gatts_char_md_t char_meta_data;
     memset(&char_meta_data, 0, sizeof(char_meta_data));
     char_meta_data.char_props.read = 1;
     char_meta_data.char_props.write = 0;
     char_meta_data.char_props.notify = 0;
     char_meta_data.char_props.indicate = 1;
     char_meta_data.p_char_user_desc = NULL;
     char_meta_data.p_char_pf = &char_presentation_format;
     char_meta_data.p_user_desc_md = NULL;
     // CCCD (Client Characteristic Configuration Descriptor) needs to be 
     // set for characteristics allowing for notifications and indications.
     char_meta_data.p_cccd_md = &cccd_meta_data;
     char_meta_data.p_sccd_md = NULL;

     // Define attribute meta data. 
     ble_gatts_attr_md_t char_attr_meta_data;
     memset(&char_attr_meta_data, 0, sizeof(char_attr_meta_data));
     // No security needed. All security implemented on the application layer.
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&char_attr_meta_data.read_perm);
     BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&char_attr_meta_data.write_perm);
     // value location
     char_attr_meta_data.vloc = BLE_GATTS_VLOC_STACK;
     // always request read authorization from application 
     char_attr_meta_data.rd_auth = 0;
     // always request write authorization from application
     char_attr_meta_data.wr_auth = 0;
     // variable length attribute
     char_attr_meta_data.vlen = 0;

     // Define characteristic attributes. 
     // This is a fixed length 17 byte data structure.
     ble_gatts_attr_t char_attributes;
     memset(&char_attributes, 0, sizeof(char_attributes));
     char_attributes.p_uuid = &ble_uuid;
     char_attributes.p_attr_md = &char_attr_meta_data;
     char_attributes.init_len = MAX_LENGTH_CFG_OUT_CHAR;
     char_attributes.init_offs = 0;
     char_attributes.max_len = MAX_LENGTH_CFG_OUT_CHAR;
     // For attributes managed by the application (BLE_GATTS_VLOC_USER)
     // rather than the BLE stack, set a pointer to the memory location here.
     char_attributes.p_value = NULL;

     // Add characteristic to service.
     if (sd_ble_gatts_characteristic_add(service_handle,
					 &char_meta_data,
					 &char_attributes,
					 &char_handle_cfg_out) != NRF_SUCCESS)
	  die();
}

static void service_init()
{
     uint32_t err_code;
     
     // Add base UUID to list of base UUIDs.
     // The uuid_type field filled by this function call can be used later to
     // refer to this base UUID.
     ble_uuid128_t base_uuid = {UUID_BASE};
     err_code = sd_ble_uuid_vs_add(&base_uuid, &uuid_type);
     if (err_code != NRF_SUCCESS)
	  die();

     // Build 128 bit service UUID by referring to base UUID using uuid_type
     // and specifying the two bytes that will replace byte 12 and 13 of the
     // base UUID. 
     ble_uuid_t ble_uuid;
     ble_uuid.type = uuid_type;
     ble_uuid.uuid = UUID_SERVICE;
     
     err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, 
					 &ble_uuid, &service_handle);
     if (err_code != NRF_SUCCESS)
	  die();
     
     // Add characteristics to service.
     add_characteristic_nonce(service_handle);
     add_characteristic_unlock(service_handle);
     add_characteristic_cfg_in(service_handle);
     add_characteristic_cfg_out(service_handle);
}

/*
static void conn_params_error_handler(uint32_t nrf_error)
{
}

static void on_conn_params_evt(ble_conn_params_evt_t * p_evt)
{
    uint32_t err_code;

    if (p_evt->evt_type == BLE_CONN_PARAMS_EVT_FAILED)
    {
        err_code = sd_ble_gap_disconnect(m_conn_handle, 
					 BLE_HCI_CONN_INTERVAL_UNACCEPTABLE);
        APP_ERROR_CHECK(err_code);
    }
}

static void conn_params_init()
{
    uint32_t err_code;
    ble_conn_params_init_t cp_init;

    memset(&cp_init, 0, sizeof(cp_init));
    cp_init.p_conn_params = NULL;
    cp_init.first_conn_params_update_delay = FIRST_CONN_PARAMS_UPDATE_DELAY;
    cp_init.next_conn_params_update_delay  = NEXT_CONN_PARAMS_UPDATE_DELAY;
    cp_init.max_conn_params_update_count = MAX_CONN_PARAMS_UPDATE_COUNT;
    cp_init.start_on_notify_cccd_handle = BLE_GATT_HANDLE_INVALID;
    cp_init.disconnect_on_fail = true;
    cp_init.evt_handler = on_conn_params_evt;
    cp_init.error_handler = conn_params_error_handler;

    err_code = ble_conn_params_init(&cp_init);
    if (err_code != NRF_SUCCESS)
	 die();
}
*/

static void advertising_init(void)
{
     ble_uuid_t adv_uuids[] = {{UUID_SERVICE, uuid_type}};
     
     ble_advdata_t advdata;
     memset(&advdata, 0, sizeof(advdata));
     advdata.name_type = BLE_ADVDATA_FULL_NAME;
     advdata.include_appearance = false;
     // LE General Discoverable Mode.
     advdata.flags = BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE;
     // Send complete set of UUIDs.
     advdata.uuids_complete.uuid_cnt = sizeof(adv_uuids)/sizeof(adv_uuids[0]);
     advdata.uuids_complete.p_uuids = adv_uuids;
     
     // No scan response data needs to be defined since everything fits into 
     // the advertisement message (the scan response can be requested by the 
     // central device to get more information from the peripheral).
     if (ble_advdata_set(&advdata, NULL) != NRF_SUCCESS)
	  die();
}

static void config_timer_evt_handler(void *p_context)
{
     UNUSED_PARAMETER(p_context);
     struct app_event app_event = {.event_type = APP_EVENT_CFG_TIMEOUT};
     app_event_queue_add(&app_event_queue, app_event);
}

static void timers_init()
{
     // Initialize application timer using RTC1 (RTC0 is used by the
     // BLE softdevice).
     APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_QUEUE_SIZE, false);

     if (app_timer_create(&config_timer, APP_TIMER_MODE_SINGLE_SHOT,
			  config_timer_evt_handler) != NRF_SUCCESS)
	  die();
}

static void start_config_timer()
{
     // Only start timer once (actually, app_timer_start() will anyway
     // ignore starting an already running timer).
     if (is_config_timer_active)
	  return;

     if (app_timer_start(config_timer, CONFIG_TIMER_TIMEOUT, NULL) !=
	 NRF_SUCCESS)
	  die();

     is_config_timer_active = true;
}

static void stop_config_timer()
{
     app_timer_stop(config_timer);
     is_config_timer_active = false;
}

static void button_evt_handler(uint8_t pin_no, uint8_t button_action)
{
     struct app_event app_event;

     switch (pin_no) {
     case PIN_BUTTON1 :
	  if (APP_BUTTON_PUSH == button_action) {
	       app_event.event_type = APP_EVENT_BUTTON1_PRESSED;
	       app_event_queue_add(&app_event_queue, app_event);
	  }
	  break;
     }
}

static void buttons_init()
{
     // Switch connects pin to GND (active low) -> second parameter = false.
     // Enable internal pull up -> NRF_GPIO_PIN_PULLUP.
     static app_button_cfg_t buttons[] = {
	  {PIN_BUTTON1, false, NRF_GPIO_PIN_PULLUP, button_evt_handler}
     };

     if (app_button_init(buttons, sizeof(buttons) / sizeof(buttons[0]),
			 BUTTON_DETECTION_DELAY) != NRF_SUCCESS)
	  die();
}

static void start_button_event_detection()
{
     if (app_button_enable() != NRF_SUCCESS)
	  die();
}

static void create_nonce()
{
     uint8_t available;
     unsigned int remaining = NONCE_LENGTH;
     unsigned int offset = 0;
     while (remaining > 0) {
	  if (sd_rand_application_bytes_available_get(&available) != NRF_SUCCESS)
	       die();
	  uint8_t length = (remaining < available) ? remaining : available;
	  if (sd_rand_application_vector_get(&nonce[offset], length) != 
	      NRF_SUCCESS)
	       die();
	  remaining -= length;
	  offset += length;
     }
}

static void ecdh_secret_key(uint8_t secret_key[ECDH_KEY_LENGTH])
{
    uint8_t available;
    unsigned int remaining = ECDH_KEY_LENGTH;
    unsigned int offset = 0;
    while (remaining > 0) {
	 if (sd_rand_application_bytes_available_get(&available) != NRF_SUCCESS)
	      die();
	 uint8_t length = (remaining < available) ? remaining : available;
	 if (sd_rand_application_vector_get(&secret_key[offset], length) != 
	     NRF_SUCCESS)
	      die();
	 remaining -= length;
	 offset += length;
    }

    // We need to clear bits 0-2 and set bit 254 to prevent small-subgroup 
    // attacks and timing attacks, respectively:
    // http://crypto.stackexchange.com/questions/12425/why-are-the-lower-3-bits-of-curve25519-ed25519-secret-keys-cleared-during-creati/12614)
    secret_key[0] &= 248;
    secret_key[ECDH_KEY_LENGTH-1] &= 127;
    secret_key[ECDH_KEY_LENGTH-1] |= 64;
}

void ecdh_public_key(uint8_t public_key[ECDH_KEY_LENGTH], 
		     const uint8_t secret_key[ECDH_KEY_LENGTH])
{
     // In the following call, base is 9.
     crypto_scalarmult_curve25519_base(public_key, secret_key);
}

void ecdh_shared_secret(uint8_t shared_secret[ECDH_KEY_LENGTH],
			const uint8_t my_secret_key[ECDH_KEY_LENGTH],
			const uint8_t other_public_key[ECDH_KEY_LENGTH])
{
     crypto_scalarmult_curve25519(shared_secret, my_secret_key, 
				  other_public_key);
}

static void display_init()
{
     hd44780_init(&lcd);
}

static void display_on()
{
     hd44780_display_on_off(&lcd, true, false, false);
}

static void display_off()
{
     hd44780_display_on_off(&lcd, false, false, false);
}

static void display_text(const char *text1, unsigned int length1,
			 const char *text2, unsigned int length2)
{
     hd44780_clear_display(&lcd);
     if (text1 != NULL)
	  hd44780_print_line(&lcd, text1, length1, 0);
     if (text2 != NULL)
	  hd44780_print_line(&lcd, text2, length2, 1);
}

static void nonce_init()
{
     create_nonce();
}

static void state_transition(struct app_event event) 
{
     switch (app_state) {
     case idle :
	  if (event.event_type == APP_EVENT_BUTTON1_PRESSED) {
	       app_state = cfg_wait_connection;
	  }
	  if (event.event_type ==  APP_EVENT_CLIENT_CONNECTED 2
#define APP_EVENT_CLIENT_SUBSCRIBED 3
#define APP_EVENT_KEY_PART1_RCVD 4
#define APP_EVENT_KEY_PART2_RCVD 5
#define APP_EVENT_ACK_RCVD 6

// Length of Diffie-Hellman keys using Eliptic Curve 25519 [bytes].
#define ECDH_KEY_LENGTH crypto_scalarmult_curve25519_BYTES

// Length of a SHAR512 [bytes].
#define SHA512_HASH_LENGTH crypto_hash_sha512_BYTES

// Length of an HMAC512-256 [bytes].
#define HMAC512_256 crypto_auth_hmacsha512256_BYTES

// Max. length of the Nonce characteristic.
#define MAX_LENGTH_NONCE_CHAR 16
 
// Max. length of Unlock characteristic [bytes].
#define MAX_LENGTH_UNLOCK_CHAR 17

// Max. length of Cfgin characteristic [bytes].
#define MAX_LENGTH_CFG_IN_CHAR 17

// Max. length of Cfgout characteristic [bytes].
#define MAX_LENGTH_CFG_OUT_CHAR 17

// Length of nonces used to avoid replay attacks [bytes].
// 128 bit nonces provide for sufficient security, assuming the following
// parameters:
// 
// 1. one request per millisecond and 100 years of operation 
//    -> less than n = 2**42 requests to protect.
//    Actually, nonces are only changed after successful authentication 
//    requests, i.e., when the door opened, so practically, we have to protect 
//    much fewer requests. Opening the door once per millisecond is highly 
//    unlikely, thus, 2**42 is a very pessimistic value.
// 2. m = 2**128 different nonces.
//
// Then the birthday paradox can be used to calculate the probability p of 
// at least one pair of requests sharing the same nonce, or, inversely,
// no nonces shared by any pair of requests. An approximation of p for n << m 
// is p(n,m) = 1 - e**((-n**2)/(2*m)), which practically evaluates to 0 for
// n = 2**42 and m = 2**128. Even for n = 2**52 (one request per us), 
// p(2**52,2**128) < 3e-8 which is about the probability to be hit by 
// lightning (about 5.5e-8).
// A nonce of 16 bytes also fits nicely into a BLE characteristic.
#define NONCE_LENGTH 16

#define DEVICE_NAME "Key20"
// Minimum connection interval in 1.25 ms. Minimum allowed value: 7.5 ms.
// 16 -> 20 ms.
#define MIN_CONN_INTERVAL 16
// Maximum connection interval in 1.25 ms. Maximum allowed value: 4000 ms.
// 100 -> 125 ms.
#define MAX_CONN_INTERVAL 100
// Number of connection intervals the device can stay silent.
#define SLAVE_LATENCY 2
// Connection supervision timeout, i.e., time until a link is considered
// lost, in 10 ms.
// 400 -> 4 s. 
#define CONN_SUP_TIMEOUT 400
// Advertisement interval in 0.625 ms; min. 20 ms, max 10.24 s.
// 64 -> 40 ms.
#define ADV_INTERVAL 64
// How long to advertise in seconds (0 = forever)
#define ADV_TIMEOUT 0

// Prescaler of RTC1 (low-frequency clock at 32.768 kHz), which is used by the 
// app timer (RTC0 is used by the softdevice, and, therefore, cannot be used by 
// the application). 
#define APP_TIMER_PRESCALER 0
#define APP_TIMER_QUEUE_SIZE 6

// Delay for debouncing buttons [ms].
#define BUTTON_DETECTION_DELAY APP_TIMER_TICKS(50, APP_TIMER_PRESCALER)

// Delay of configuration timer [ms].
#define CONFIG_TIMER_TIMEOUT APP_TIMER_TICKS(30000, APP_TIMER_PRESCALER)

// Service and charateristic UUIDs in Little Endian format.
// The 16 bit values will become byte 12 and 13 of the 128 bit UUID:
// 0x0cddxxxx-df68-4777-8d2e-52fa8ad22820
#define UUID_BASE {0xaf, 0x1f, 0xcf, 0xe7, 0x7d, 0x62, 0x53, 0x8a, \
	           0x58, 0x4c, 0xf4, 0x5f, 0x00, 0x00, 0x9d, 0x0a}
#define UUID_SERVICE 0x0001
#define UUID_CHARACTERISTIC_NONCE 0x0002
#define UUID_CHARACTERISTIC_UNLOCK 0x0003
#define UUID_CHARACTERISTIC_CFG_IN 0x0004
#define UUID_CHARACTERISTIC_CFG_OUT 0x0004

// Application states.
enum app_states {idle, cfg_wait_connection, cfg_wait_subscription, 
		 cfg_wait_key_part1, cfg_wait_key_part2, cfg_wait_ack, 
		 cfg_wait_confirmation, connected, wait_hmac_part2} ;

enum app_states app_state = idle;

// Definition of the connected LCD. 
struct hd44780 lcd = {
      .pin_rs = PIN_LCD_RS, 
      .pin_e = PIN_LCD_E, 
      .pin_db4 = PIN_LCD_DB4, 
      .pin_db5 = PIN_LCD_DB5, 
      .pin_db6 = PIN_LCD_DB6,
      .pin_db7 = PIN_LCD_DB7, 
      .rows = 2,
      .columns = 16
};

APP_TIMER_DEF(config_timer);

uint8_t uuid_type;
uint16_t service_handle;
ble_gatts_char_handles_t char_handle_nonce;
ble_gatts_char_handles_t char_handle_unlock;
ble_gatts_char_handles_t char_handle_cfg_in;
ble_gatts_char_handles_t char_handle_cfg_out;
uint16_t conn_handle = BLE_CONN_HANDLE_INVALID; 

uint8_t nonce[NONCE_LENGTH];

bool is_config_timer_active = true;

struct app_event_queue app_event_queue;

static void display_text(const char *text1, unsigned int length1,
			 const char *text2, unsigned int length2);

static void init_app_event_queue()
{
     app_event_queue_init(&app_event_queue, APP_EVENT_QUEUE_SIZE);
}

static void led_off()
{
     // LED is active low -> set to turn off.
     nrf_gpio_pin_set(PIN_LED);
}

static void led_on()
{
     // LED is active low -> clear to turn on.
     nrf_gpio_pin_clear(PIN_LED);
}

static void die()
{
     display_text("Error", 5, NULL, 0);

     while (1);
}

static void led_init()
{
     nrf_gpio_cfg_output(PIN_LED);
     led_off();
}

static void start_advertising()
{
    uint32_t err_code;
    ble_gap_adv_params_t adv_params;

    memset(&adv_params, 0, sizeof(adv_params));
    adv_params.type = BLE_GAP_ADV_TYPE_ADV_IND;
    adv_params.p_peer_addr = NULL;
    adv_params.fp = BLE_GAP_ADV_FP_ANY;
    adv_params.interval = ADV_INTERVAL;
    adv_params.timeout = ADV_TIMEOUT;

    err_code = sd_ble_gap_adv_start(&adv_params);
    if (err_code != NRF_SUCCESS)
	 die();
}

static void ble_evt_handler(ble_evt_t *ble_evt)
{
     ble_gatts_evt_write_t *evt_write;
     uint8_t char_data;

     switch (ble_evt->header.evt_id) {
     case BLE_GAP_EVT_CONNECTED:
	  conn_handle = ble_evt->evt.gap_evt.conn_handle;
	  break;
     case BLE_GAP_EVT_DISCONNECTED:
	  conn_handle = BLE_CONN_HANDLE_INVALID;
	  start_advertising();
	  break;
     case BLE_GAP_EVT_SEC_PARAMS_REQUEST:
	  // Pairing not supported
	  sd_ble_gap_sec_params_reply(conn_handle, 
				      BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP,
				      NULL, NULL);
	  break;
     case BLE_GATTS_EVT_WRITE:
          evt_write = &ble_evt->evt.gatts_evt.params.write;
	  if (evt_write->handle == char_handle_nonce.value_handle && 
	      evt_write->len == 1) {
	       // Our charateristic value is a simple byte
	       char_data = evt_write->data[0];
	       // TODO: do something with this byte
	  }
	  break;
     case BLE_GATTS_EVT_SYS_ATTR_MISSING:
	  // No system attributes have been stored.
	  sd_ble_gatts_sys_attr_set(conn_handle, NULL, 0, 0);
	  break;
    }
}

static void ble_stack_init()
{
     uint32_t err_code;

     // The softdevice uses RTC0 (32 kHz real-time clock) for timing.
     // We use an external crystal with 20 ppm accuracy.
     SOFTDEVICE_HANDLER_INIT(NRF_CLOCK_LFCLKSRC_XTAL_20_PPM, false);

     // Enable BLE stack 
     ble_enable_params_t ble_enable_params;
     memset(&ble_enable_params, 0, sizeof(ble_enable_params));
     err_code = sd_ble_enable(&ble_enable_params);
     if (err_code != NRF_SUCCESS)
	  die();
     
     // Set Bluetooth address?
     ble_gap_addr_t addr;
     err_code = sd_ble_gap_address_get(&addr);
     APP_ERROR_CHECK(err_code);
     err_code = sd_ble_gap_address_set(BLE_GAP_ADDR_CYCLE_MODE_NONE, &addr);
     if (err_code != NRF_SUCCESS)
	  die();
     
     // Subscribe for BLE events.
     err_code = softdevice_ble_evt_handler_set(ble_evt_handler);
     if (err_code != NRF_SUCCESS)
	  die();
}

static void gap_init()
{
     uint32_t err_code;
     ble_gap_conn_params_t gap_conn_params;
     ble_gap_conn_sec_mode_t sec_mode;

     // Open link, no encryption required on BLE layer. 
     // Security is handled only on the application layer. 
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&sec_mode);
     
     // Set device name.
     err_code = sd_ble_gap_device_name_set(&sec_mode,
					   (const uint8_t *) DEVICE_NAME,
					   strlen(DEVICE_NAME));
     if (err_code != NRF_SUCCESS)
	  die();
     
     // Set connection parameters.
     memset(&gap_conn_params, 0, sizeof(gap_conn_params));
     gap_conn_params.min_conn_interval = MIN_CONN_INTERVAL;
     gap_conn_params.max_conn_interval = MAX_CONN_INTERVAL;
     gap_conn_params.slave_latency = SLAVE_LATENCY;
     gap_conn_params.conn_sup_timeout = CONN_SUP_TIMEOUT;     
     err_code = sd_ble_gap_ppcp_set(&gap_conn_params);
     if (err_code != NRF_SUCCESS)
	  die();
}

static void add_characteristic_nonce(uint16_t service_handle)
{
     // Characteristic UUID.
     ble_uuid_t ble_uuid;
     ble_uuid.type = uuid_type;
     ble_uuid.uuid = UUID_CHARACTERISTIC_NONCE;

     // Define characteristic presentation format.
     // The nonce is a 16 byte number, which is declared as opaque struct.
     ble_gatts_char_pf_t char_presentation_format;
     memset(&char_presentation_format, 0, sizeof(char_presentation_format));
     char_presentation_format.format = BLE_GATT_CPF_FORMAT_STRUCT;
     char_presentation_format.exponent = 0;
     char_presentation_format.unit = 0x2700; // unitless

     // Define characteristic meta data.
     // The nonce is only readable.
     ble_gatts_char_md_t char_meta_data;
     memset(&char_meta_data, 0, sizeof(char_meta_data));
     char_meta_data.char_props.read = 1;
     char_meta_data.char_props.write = 0;
     char_meta_data.char_props.notify = 0;
     char_meta_data.char_props.indicate = 0;
     char_meta_data.p_char_user_desc = NULL;
     char_meta_data.p_char_pf = &char_presentation_format;
     char_meta_data.p_user_desc_md = NULL;
     // CCCD (Client Characteristic Configuration Descriptor) only needs to be 
     // set for characteristics allowing for notifications and indications.
     char_meta_data.p_cccd_md = NULL;
     char_meta_data.p_sccd_md = NULL;

     // Define attribute meta data. 
     ble_gatts_attr_md_t char_attr_meta_data;
     memset(&char_attr_meta_data, 0, sizeof(char_attr_meta_data));
     // No security needed. All security implemented on the application layer.
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&char_attr_meta_data.read_perm);
     BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&char_attr_meta_data.write_perm);
     // value location
     char_attr_meta_data.vloc = BLE_GATTS_VLOC_STACK;
     // always request read authorization from application 
     char_attr_meta_data.rd_auth = 0;
     // always request write authorization from application
     char_attr_meta_data.wr_auth = 0;
     // variable length attribute
     char_attr_meta_data.vlen = 0;

     // Define characteristic attributes. 
     // Nonce is a fixed length 16 byte data structure.
     ble_gatts_attr_t char_attributes;
     memset(&char_attributes, 0, sizeof(char_attributes));
     char_attributes.p_uuid = &ble_uuid;
     char_attributes.p_attr_md = &char_attr_meta_data;
     char_attributes.init_len = MAX_LENGTH_NONCE_CHAR;
     char_attributes.init_offs = 0;
     char_attributes.max_len = MAX_LENGTH_NONCE_CHAR;
     // For attributes managed by the application (BLE_GATTS_VLOC_USER)
     // rather than the BLE stack, set a pointer to the memory location here.
     char_attributes.p_value = NULL;

     // Add characteristic to service.
     if (sd_ble_gatts_characteristic_add(service_handle,
					 &char_meta_data,
					 &char_attributes,
					 &char_handle_nonce) != NRF_SUCCESS)
	  die();

     // Set initial characteristic value.
     ble_gatts_value_t value;
     memset(&value, 0, sizeof(value));
     value.len = sizeof(nonce);
     value.offset  = 0;
     value.p_value = nonce;
     if (sd_ble_gatts_value_set(BLE_CONN_HANDLE_INVALID, 
				char_handle_nonce.value_handle, &value) != 
	 NRF_SUCCESS)
	  die();
}

static void add_characteristic_unlock(uint16_t service_handle)
{
     // Characteristic UUID.
     ble_uuid_t ble_uuid;
     ble_uuid.type = uuid_type;
     ble_uuid.uuid = UUID_CHARACTERISTIC_UNLOCK;

     // Define characteristic presentation format.
     // This characteristic transports a 256 bit HMAC to authenticate the
     // door open request. 256 bit = 32 bytes are too long for a 
     // characteristic. So we split up the request into two 16 byte write
     // operations to the characteristic. Moreover, we include the key number
     // in the request as another byte. Thus, this is a 17 byte opaque
     // struct.
     ble_gatts_char_pf_t char_presentation_format;
     memset(&char_presentation_format, 0, sizeof(char_presentation_format));
     char_presentation_format.format = BLE_GATT_CPF_FORMAT_STRUCT;
     char_presentation_format.exponent = 0;
     char_presentation_format.unit = 0x2700; // unitless

     // Define characteristic meta data.
     // The Unlock characteristic must support writing to receive authentication
     // data.
     ble_gatts_char_md_t char_meta_data;
     memset(&char_meta_data, 0, sizeof(char_meta_data));
     char_meta_data.char_props.read = 1;
     char_meta_data.char_props.write = 1;
     char_meta_data.char_props.notify = 0;
     char_meta_data.char_props.indicate = 0;
     char_meta_data.p_char_user_desc = NULL;
     char_meta_data.p_char_pf = &char_presentation_format;
     char_meta_data.p_user_desc_md = NULL;
     // CCCD (Client Characteristic Configuration Descriptor) only needs to be 
     // set for characteristics allowing for notifications and indications.
     char_meta_data.p_cccd_md = NULL;
     char_meta_data.p_sccd_md = NULL;

     // Define attribute meta data. 
     ble_gatts_attr_md_t char_attr_meta_data;
     memset(&char_attr_meta_data, 0, sizeof(char_attr_meta_data));
     // No security needed. All security implemented on the application layer.
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&char_attr_meta_data.read_perm);
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&char_attr_meta_data.write_perm);
     // value location
     char_attr_meta_data.vloc = BLE_GATTS_VLOC_STACK;
     // always request read authorization from application 
     char_attr_meta_data.rd_auth = 0;
     // always request write authorization from application
     char_attr_meta_data.wr_auth = 0;
     // variable length attribute
     char_attr_meta_data.vlen = 0;

     // Define characteristic attributes. 
     // This is a fixed length 17 byte data structure.
     ble_gatts_attr_t char_attributes;
     memset(&char_attributes, 0, sizeof(char_attributes));
     char_attributes.p_uuid = &ble_uuid;
     char_attributes.p_attr_md = &char_attr_meta_data;
     char_attributes.init_len = MAX_LENGTH_UNLOCK_CHAR;
     char_attributes.init_offs = 0;
     char_attributes.max_len = MAX_LENGTH_UNLOCK_CHAR;
     // For attributes managed by the application (BLE_GATTS_VLOC_USER)
     // rather than the BLE stack, set a pointer to the memory location here.
     char_attributes.p_value = NULL;

     // Add characteristic to service.
     if (sd_ble_gatts_characteristic_add(service_handle,
					 &char_meta_data,
					 &char_attributes,
					 &char_handle_unlock) != NRF_SUCCESS)
	  die();
}

static void add_characteristic_cfg_in(uint16_t service_handle)
{
     // Characteristic UUID.
     ble_uuid_t ble_uuid;
     ble_uuid.type = uuid_type;
     ble_uuid.uuid = UUID_CHARACTERISTIC_CFG_IN;

     // Define characteristic presentation format.
     // This characteristic transports a 32 byte public key (split into two
     // 16 byte parts due to characteristic length restrictions) for
     // key exchange, plus one byte defining the key number.
     // Thus, this is a 17 byte opaque struct.
     ble_gatts_char_pf_t char_presentation_format;
     memset(&char_presentation_format, 0, sizeof(char_presentation_format));
     char_presentation_format.format = BLE_GATT_CPF_FORMAT_STRUCT;
     char_presentation_format.exponent = 0;
     char_presentation_format.unit = 0x2700; // unitless

     // Define characteristic meta data.
     // The config-in characteristic must support writing to receive
     // configuration data.
     ble_gatts_char_md_t char_meta_data;
     memset(&char_meta_data, 0, sizeof(char_meta_data));
     char_meta_data.char_props.read = 1;
     char_meta_data.char_props.write = 1;
     char_meta_data.char_props.notify = 0;
     char_meta_data.char_props.indicate = 0;
     char_meta_data.p_char_user_desc = NULL;
     char_meta_data.p_char_pf = &char_presentation_format;
     char_meta_data.p_user_desc_md = NULL;
     // CCCD (Client Characteristic Configuration Descriptor) only needs to be 
     // set for characteristics allowing for notifications and indications.
     char_meta_data.p_cccd_md = NULL;
     char_meta_data.p_sccd_md = NULL;

     // Define attribute meta data. 
     ble_gatts_attr_md_t char_attr_meta_data;
     memset(&char_attr_meta_data, 0, sizeof(char_attr_meta_data));
     // No security needed. All security implemented on the application layer.
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&char_attr_meta_data.read_perm);
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&char_attr_meta_data.write_perm);
     // value location
     char_attr_meta_data.vloc = BLE_GATTS_VLOC_STACK;
     // always request read authorization from application 
     char_attr_meta_data.rd_auth = 0;
     // always request write authorization from application
     char_attr_meta_data.wr_auth = 0;
     // variable length attribute
     char_attr_meta_data.vlen = 0;

     // Define characteristic attributes. 
     // This is a fixed length 17 byte data structure.
     ble_gatts_attr_t char_attributes;
     memset(&char_attributes, 0, sizeof(char_attributes));
     char_attributes.p_uuid = &ble_uuid;
     char_attributes.p_attr_md = &char_attr_meta_data;
     char_attributes.init_len = MAX_LENGTH_CFG_IN_CHAR;
     char_attributes.init_offs = 0;
     char_attributes.max_len = MAX_LENGTH_CFG_IN_CHAR;
     // For attributes managed by the application (BLE_GATTS_VLOC_USER)
     // rather than the BLE stack, set a pointer to the memory location here.
     char_attributes.p_value = NULL;

     // Add characteristic to service.
     if (sd_ble_gatts_characteristic_add(service_handle,
					 &char_meta_data,
					 &char_attributes,
					 &char_handle_cfg_in) != NRF_SUCCESS)
	  die();
}

static void add_characteristic_cfg_out(uint16_t service_handle)
{
     // Characteristic UUID.
     ble_uuid_t ble_uuid;
     ble_uuid.type = uuid_type;
     ble_uuid.uuid = UUID_CHARACTERISTIC_CFG_OUT;

     // Define characteristic presentation format.
     // This characteristic transports a 32 byte public key (split into two
     // 16 byte parts due to characteristic length restrictions) for
     // key exchange, plus one byte defining the key number.
     // Thus, this is a 17 byte opaque struct.
     ble_gatts_char_pf_t char_presentation_format;
     memset(&char_presentation_format, 0, sizeof(char_presentation_format));
     char_presentation_format.format = BLE_GATT_CPF_FORMAT_STRUCT;
     char_presentation_format.exponent = 0;
     char_presentation_format.unit = 0x2700; // unitless

     // Define CCCD attributes. 
     // CCCD (Client Characteristic Configuration Descriptor) is used by the
     // client to enable notifications or indications by writing a flag to the
     // CCCD attribute.
     ble_gatts_attr_md_t cccd_meta_data;
     memset(&cccd_meta_data, 0, sizeof(cccd_meta_data));
     // CCCD must be read and writable. 
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_meta_data.read_perm);
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_meta_data.write_perm);
     cccd_meta_data.vloc = BLE_GATTS_VLOC_STACK;

     // Define characteristic meta data.
     // The config-out characteristic must suppport indications for sending
     // config data to the client.
     ble_gatts_char_md_t char_meta_data;
     memset(&char_meta_data, 0, sizeof(char_meta_data));
     char_meta_data.char_props.read = 1;
     char_meta_data.char_props.write = 0;
     char_meta_data.char_props.notify = 0;
     char_meta_data.char_props.indicate = 1;
     char_meta_data.p_char_user_desc = NULL;
     char_meta_data.p_char_pf = &char_presentation_format;
     char_meta_data.p_user_desc_md = NULL;
     // CCCD (Client Characteristic Configuration Descriptor) needs to be 
     // set for characteristics allowing for notifications and indications.
     char_meta_data.p_cccd_md = &cccd_meta_data;
     char_meta_data.p_sccd_md = NULL;

     // Define attribute meta data. 
     ble_gatts_attr_md_t char_attr_meta_data;
     memset(&char_attr_meta_data, 0, sizeof(char_attr_meta_data));
     // No security needed. All security implemented on the application layer.
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&char_attr_meta_data.read_perm);
     BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&char_attr_meta_data.write_perm);
     // value location
     char_attr_meta_data.vloc = BLE_GATTS_VLOC_STACK;
     // always request read authorization from application 
     char_attr_meta_data.rd_auth = 0;
     // always request write authorization from application
     char_attr_meta_data.wr_auth = 0;
     // variable length attribute
     char_attr_meta_data.vlen = 0;

     // Define characteristic attributes. 
     // This is a fixed length 17 byte data structure.
     ble_gatts_attr_t char_attributes;
     memset(&char_attributes, 0, sizeof(char_attributes));
     char_attributes.p_uuid = &ble_uuid;
     char_attributes.p_attr_md = &char_attr_meta_data;
     char_attributes.init_len = MAX_LENGTH_CFG_OUT_CHAR;
     char_attributes.init_offs = 0;
     char_attributes.max_len = MAX_LENGTH_CFG_OUT_CHAR;
     // For attributes managed by the application (BLE_GATTS_VLOC_USER)
     // rather than the BLE stack, set a pointer to the memory location here.
     char_attributes.p_value = NULL;

     // Add characteristic to service.
     if (sd_ble_gatts_characteristic_add(service_handle,
					 &char_meta_data,
					 &char_attributes,
					 &char_handle_cfg_out) != NRF_SUCCESS)
	  die();
}

static void service_init()
{
     uint32_t err_code;
     
     // Add base UUID to list of base UUIDs.
     // The uuid_type field filled by this function call can be used later to
     // refer to this base UUID.
     ble_uuid128_t base_uuid = {UUID_BASE};
     err_code = sd_ble_uuid_vs_add(&base_uuid, &uuid_type);
     if (err_code != NRF_SUCCESS)
	  die();

     // Build 128 bit service UUID by referring to base UUID using uuid_type
     // and specifying the two bytes that will replace byte 12 and 13 of the
     // base UUID. 
     ble_uuid_t ble_uuid;
     ble_uuid.type = uuid_type;
     ble_uuid.uuid = UUID_SERVICE;
     
     err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, 
					 &ble_uuid, &service_handle);
     if (err_code != NRF_SUCCESS)
	  die();
     
     // Add characteristics to service.
     add_characteristic_nonce(service_handle);
     add_characteristic_unlock(service_handle);
     add_characteristic_cfg_in(service_handle);
     add_characteristic_cfg_out(service_handle);
}

/*
static void conn_params_error_handler(uint32_t nrf_error)
{
}

static void on_conn_params_evt(ble_conn_params_evt_t * p_evt)
{
    uint32_t err_code;

    if (p_evt->evt_type == BLE_CONN_PARAMS_EVT_FAILED)
    {
        err_code = sd_ble_gap_disconnect(m_conn_handle, 
					 BLE_HCI_CONN_INTERVAL_UNACCEPTABLE);
        APP_ERROR_CHECK(err_code);
    }
}

static void conn_params_init()
{
    uint32_t err_code;
    ble_conn_params_init_t cp_init;

    memset(&cp_init, 0, sizeof(cp_init));
    cp_init.p_conn_params = NULL;
    cp_init.first_conn_params_update_delay = FIRST_CONN_PARAMS_UPDATE_DELAY;
    cp_init.next_conn_params_update_delay  = NEXT_CONN_PARAMS_UPDATE_DELAY;
    cp_init.max_conn_params_update_count = MAX_CONN_PARAMS_UPDATE_COUNT;
    cp_init.start_on_notify_cccd_handle = BLE_GATT_HANDLE_INVALID;
    cp_init.disconnect_on_fail = true;
    cp_init.evt_handler = on_conn_params_evt;
    cp_init.error_handler = conn_params_error_handler;

    err_code = ble_conn_params_init(&cp_init);
    if (err_code != NRF_SUCCESS)
	 die();
}
*/

static void advertising_init(void)
{
     ble_uuid_t adv_uuids[] = {{UUID_SERVICE, uuid_type}};
     
     ble_advdata_t advdata;
     memset(&advdata, 0, sizeof(advdata));
     advdata.name_type = BLE_ADVDATA_FULL_NAME;
     advdata.include_appearance = false;
     // LE General Discoverable Mode.
     advdata.flags = BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE;
     // Send complete set of UUIDs.
     advdata.uuids_complete.uuid_cnt = sizeof(adv_uuids)/sizeof(adv_uuids[0]);
     advdata.uuids_complete.p_uuids = adv_uuids;
     
     // No scan response data needs to be defined since everything fits into 
     // the advertisement message (the scan response can be requested by the 
     // central device to get more information from the peripheral).
     if (ble_advdata_set(&advdata, NULL) != NRF_SUCCESS)
	  die();
}

static void config_timer_evt_handler(void *p_context)
{
     UNUSED_PARAMETER(p_context);
     struct app_event app_event = {.event_type = APP_EVENT_CFG_TIMEOUT};
     app_event_queue_add(&app_event_queue, app_event);
}

static void timers_init()
{
     // Initialize application timer using RTC1 (RTC0 is used by the
     // BLE softdevice).
     APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_QUEUE_SIZE, false);

     if (app_timer_create(&config_timer, APP_TIMER_MODE_SINGLE_SHOT,
			  config_timer_evt_handler) != NRF_SUCCESS)
	  die();
}

static void start_config_timer()
{
     // Only start timer once (actually, app_timer_start() will anyway
     // ignore starting an already running timer).
     if (is_config_timer_active)
	  return;

     if (app_timer_start(config_timer, CONFIG_TIMER_TIMEOUT, NULL) !=
	 NRF_SUCCESS)
	  die();

     is_config_timer_active = true;
}

static void stop_config_timer()
{
     app_timer_stop(config_timer);
     is_config_timer_active = false;
}

static void button_evt_handler(uint8_t pin_no, uint8_t button_action)
{
     struct app_event app_event;

     switch (pin_no) {
     case PIN_BUTTON1 :
	  if (APP_BUTTON_PUSH == button_action) {
	       app_event.event_type = APP_EVENT_BUTTON1_PRESSED;
	       app_event_queue_add(&app_event_queue, app_event);
	  }
	  break;
     }
}

static void buttons_init()
{
     // Switch connects pin to GND (active low) -> second parameter = false.
     // Enable internal pull up -> NRF_GPIO_PIN_PULLUP.
     static app_button_cfg_t buttons[] = {
	  {PIN_BUTTON1, false, NRF_GPIO_PIN_PULLUP, button_evt_handler}
     };

     if (app_button_init(buttons, sizeof(buttons) / sizeof(buttons[0]),
			 BUTTON_DETECTION_DELAY) != NRF_SUCCESS)
	  die();
}

static void start_button_event_detection()
{
     if (app_button_enable() != NRF_SUCCESS)
	  die();
}

static void create_nonce()
{
     uint8_t available;
     unsigned int remaining = NONCE_LENGTH;
     unsigned int offset = 0;
     while (remaining > 0) {
	  if (sd_rand_application_bytes_available_get(&available) != NRF_SUCCESS)
	       die();
	  uint8_t length = (remaining < available) ? remaining : available;
	  if (sd_rand_application_vector_get(&nonce[offset], length) != 
	      NRF_SUCCESS)
	       die();
	  remaining -= length;
	  offset += length;
     }
}

static void ecdh_secret_key(uint8_t secret_key[ECDH_KEY_LENGTH])
{
    uint8_t available;
    unsigned int remaining = ECDH_KEY_LENGTH;
    unsigned int offset = 0;
    while (remaining > 0) {
	 if (sd_rand_application_bytes_available_get(&available) != NRF_SUCCESS)
	      die();
	 uint8_t length = (remaining < available) ? remaining : available;
	 if (sd_rand_application_vector_get(&secret_key[offset], length) != 
	     NRF_SUCCESS)
	      die();
	 remaining -= length;
	 offset += length;
    }

    // We need to clear bits 0-2 and set bit 254 to prevent small-subgroup 
    // attacks and timing attacks, respectively:
    // http://crypto.stackexchange.com/questions/12425/why-are-the-lower-3-bits-of-curve25519-ed25519-secret-keys-cleared-during-creati/12614)
    secret_key[0] &= 248;
    secret_key[ECDH_KEY_LENGTH-1] &= 127;
    secret_key[ECDH_KEY_LENGTH-1] |= 64;
}

void ecdh_public_key(uint8_t public_key[ECDH_KEY_LENGTH], 
		     const uint8_t secret_key[ECDH_KEY_LENGTH])
{
     // In the following call, base is 9.
     crypto_scalarmult_curve25519_base(public_key, secret_key);
}

void ecdh_shared_secret(uint8_t shared_secret[ECDH_KEY_LENGTH],
			const uint8_t my_secret_key[ECDH_KEY_LENGTH],
			const uint8_t other_public_key[ECDH_KEY_LENGTH])
{
     crypto_scalarmult_curve25519(shared_secret, my_secret_key, 
				  other_public_key);
}

static void display_init()
{
     hd44780_init(&lcd);
}

static void display_on()
{
     hd44780_display_on_off(&lcd, true, false, false);
}

static void display_off()
{
     hd44780_display_on_off(&lcd, false, false, false);
}

static void display_text(const char *text1, unsigned int length1,
			 const char *text2, unsigned int length2)
{
     hd44780_clear_display(&lcd);
     if (text1 != NULL)
	  hd44780_print_line(&lcd, text1, length1, 0);
     if (text2 != NULL)
	  hd44780_print_line(&lcd, text2, length2, 1);
}

static void nonce_init()
{
     create_nonce();
}

static void state_transition(struct app_event event) 
{
     switch (app_state) {
     case idle :
	  if (event.event_type == APP_EVENT_BUTTON1_PRESSED) {
	       app_state = cfg_wait_connection;
	  }
	  if (event.event_type ==  APP_EVENT_CLIENT_CONNECTED 2
#define APP_EVENT_CLIENT_SUBSCRIBED 3
#define APP_EVENT_KEY_PART1_RCVD 4
#define APP_EVENT_KEY_PART2_RCVD 5
#define APP_EVENT_ACK_RCVD 6

// Length of Diffie-Hellman keys using Eliptic Curve 25519 [bytes].
#define ECDH_KEY_LENGTH crypto_scalarmult_curve25519_BYTES

// Length of a SHAR512 [bytes].
#define SHA512_HASH_LENGTH crypto_hash_sha512_BYTES

// Length of an HMAC512-256 [bytes].
#define HMAC512_256 crypto_auth_hmacsha512256_BYTES

// Max. length of the Nonce characteristic.
#define MAX_LENGTH_NONCE_CHAR 16
 
// Max. length of Unlock characteristic [bytes].
#define MAX_LENGTH_UNLOCK_CHAR 17

// Max. length of Cfgin characteristic [bytes].
#define MAX_LENGTH_CFG_IN_CHAR 17

// Max. length of Cfgout characteristic [bytes].
#define MAX_LENGTH_CFG_OUT_CHAR 17

// Length of nonces used to avoid replay attacks [bytes].
// 128 bit nonces provide for sufficient security, assuming the following
// parameters:
// 
// 1. one request per millisecond and 100 years of operation 
//    -> less than n = 2**42 requests to protect.
//    Actually, nonces are only changed after successful authentication 
//    requests, i.e., when the door opened, so practically, we have to protect 
//    much fewer requests. Opening the door once per millisecond is highly 
//    unlikely, thus, 2**42 is a very pessimistic value.
// 2. m = 2**128 different nonces.
//
// Then the birthday paradox can be used to calculate the probability p of 
// at least one pair of requests sharing the same nonce, or, inversely,
// no nonces shared by any pair of requests. An approximation of p for n << m 
// is p(n,m) = 1 - e**((-n**2)/(2*m)), which practically evaluates to 0 for
// n = 2**42 and m = 2**128. Even for n = 2**52 (one request per us), 
// p(2**52,2**128) < 3e-8 which is about the probability to be hit by 
// lightning (about 5.5e-8).
// A nonce of 16 bytes also fits nicely into a BLE characteristic.
#define NONCE_LENGTH 16

#define DEVICE_NAME "Key20"
// Minimum connection interval in 1.25 ms. Minimum allowed value: 7.5 ms.
// 16 -> 20 ms.
#define MIN_CONN_INTERVAL 16
// Maximum connection interval in 1.25 ms. Maximum allowed value: 4000 ms.
// 100 -> 125 ms.
#define MAX_CONN_INTERVAL 100
// Number of connection intervals the device can stay silent.
#define SLAVE_LATENCY 2
// Connection supervision timeout, i.e., time until a link is considered
// lost, in 10 ms.
// 400 -> 4 s. 
#define CONN_SUP_TIMEOUT 400
// Advertisement interval in 0.625 ms; min. 20 ms, max 10.24 s.
// 64 -> 40 ms.
#define ADV_INTERVAL 64
// How long to advertise in seconds (0 = forever)
#define ADV_TIMEOUT 0

// Prescaler of RTC1 (low-frequency clock at 32.768 kHz), which is used by the 
// app timer (RTC0 is used by the softdevice, and, therefore, cannot be used by 
// the application). 
#define APP_TIMER_PRESCALER 0
#define APP_TIMER_QUEUE_SIZE 6

// Delay for debouncing buttons [ms].
#define BUTTON_DETECTION_DELAY APP_TIMER_TICKS(50, APP_TIMER_PRESCALER)

// Delay of configuration timer [ms].
#define CONFIG_TIMER_TIMEOUT APP_TIMER_TICKS(30000, APP_TIMER_PRESCALER)

// Service and charateristic UUIDs in Little Endian format.
// The 16 bit values will become byte 12 and 13 of the 128 bit UUID:
// 0x0cddxxxx-df68-4777-8d2e-52fa8ad22820
#define UUID_BASE {0xaf, 0x1f, 0xcf, 0xe7, 0x7d, 0x62, 0x53, 0x8a, \
	           0x58, 0x4c, 0xf4, 0x5f, 0x00, 0x00, 0x9d, 0x0a}
#define UUID_SERVICE 0x0001
#define UUID_CHARACTERISTIC_NONCE 0x0002
#define UUID_CHARACTERISTIC_UNLOCK 0x0003
#define UUID_CHARACTERISTIC_CFG_IN 0x0004
#define UUID_CHARACTERISTIC_CFG_OUT 0x0004

// Application states.
enum app_states {idle, cfg_wait_connection, cfg_wait_subscription, 
		 cfg_wait_key_part1, cfg_wait_key_part2, cfg_wait_ack, 
		 cfg_wait_confirmation, connected, wait_hmac_part2} ;

enum app_states app_state = idle;

// Definition of the connected LCD. 
struct hd44780 lcd = {
      .pin_rs = PIN_LCD_RS, 
      .pin_e = PIN_LCD_E, 
      .pin_db4 = PIN_LCD_DB4, 
      .pin_db5 = PIN_LCD_DB5, 
      .pin_db6 = PIN_LCD_DB6,
      .pin_db7 = PIN_LCD_DB7, 
      .rows = 2,
      .columns = 16
};

APP_TIMER_DEF(config_timer);

uint8_t uuid_type;
uint16_t service_handle;
ble_gatts_char_handles_t char_handle_nonce;
ble_gatts_char_handles_t char_handle_unlock;
ble_gatts_char_handles_t char_handle_cfg_in;
ble_gatts_char_handles_t char_handle_cfg_out;
uint16_t conn_handle = BLE_CONN_HANDLE_INVALID; 

uint8_t nonce[NONCE_LENGTH];

bool is_config_timer_active = true;

struct app_event_queue app_event_queue;

static void display_text(const char *text1, unsigned int length1,
			 const char *text2, unsigned int length2);

static void init_app_event_queue()
{
     app_event_queue_init(&app_event_queue, APP_EVENT_QUEUE_SIZE);
}

static void led_off()
{
     // LED is active low -> set to turn off.
     nrf_gpio_pin_set(PIN_LED);
}

static void led_on()
{
     // LED is active low -> clear to turn on.
     nrf_gpio_pin_clear(PIN_LED);
}

static void die()
{
     display_text("Error", 5, NULL, 0);

     while (1);
}

static void led_init()
{
     nrf_gpio_cfg_output(PIN_LED);
     led_off();
}

static void start_advertising()
{
    uint32_t err_code;
    ble_gap_adv_params_t adv_params;

    memset(&adv_params, 0, sizeof(adv_params));
    adv_params.type = BLE_GAP_ADV_TYPE_ADV_IND;
    adv_params.p_peer_addr = NULL;
    adv_params.fp = BLE_GAP_ADV_FP_ANY;
    adv_params.interval = ADV_INTERVAL;
    adv_params.timeout = ADV_TIMEOUT;

    err_code = sd_ble_gap_adv_start(&adv_params);
    if (err_code != NRF_SUCCESS)
	 die();
}

static void ble_evt_handler(ble_evt_t *ble_evt)
{
     ble_gatts_evt_write_t *evt_write;
     uint8_t char_data;

     switch (ble_evt->header.evt_id) {
     case BLE_GAP_EVT_CONNECTED:
	  conn_handle = ble_evt->evt.gap_evt.conn_handle;
	  break;
     case BLE_GAP_EVT_DISCONNECTED:
	  conn_handle = BLE_CONN_HANDLE_INVALID;
	  start_advertising();
	  break;
     case BLE_GAP_EVT_SEC_PARAMS_REQUEST:
	  // Pairing not supported
	  sd_ble_gap_sec_params_reply(conn_handle, 
				      BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP,
				      NULL, NULL);
	  break;
     case BLE_GATTS_EVT_WRITE:
          evt_write = &ble_evt->evt.gatts_evt.params.write;
	  if (evt_write->handle == char_handle_nonce.value_handle && 
	      evt_write->len == 1) {
	       // Our charateristic value is a simple byte
	       char_data = evt_write->data[0];
	       // TODO: do something with this byte
	  }
	  break;
     case BLE_GATTS_EVT_SYS_ATTR_MISSING:
	  // No system attributes have been stored.
	  sd_ble_gatts_sys_attr_set(conn_handle, NULL, 0, 0);
	  break;
    }
}

static void ble_stack_init()
{
     uint32_t err_code;

     // The softdevice uses RTC0 (32 kHz real-time clock) for timing.
     // We use an external crystal with 20 ppm accuracy.
     SOFTDEVICE_HANDLER_INIT(NRF_CLOCK_LFCLKSRC_XTAL_20_PPM, false);

     // Enable BLE stack 
     ble_enable_params_t ble_enable_params;
     memset(&ble_enable_params, 0, sizeof(ble_enable_params));
     err_code = sd_ble_enable(&ble_enable_params);
     if (err_code != NRF_SUCCESS)
	  die();
     
     // Set Bluetooth address?
     ble_gap_addr_t addr;
     err_code = sd_ble_gap_address_get(&addr);
     APP_ERROR_CHECK(err_code);
     err_code = sd_ble_gap_address_set(BLE_GAP_ADDR_CYCLE_MODE_NONE, &addr);
     if (err_code != NRF_SUCCESS)
	  die();
     
     // Subscribe for BLE events.
     err_code = softdevice_ble_evt_handler_set(ble_evt_handler);
     if (err_code != NRF_SUCCESS)
	  die();
}

static void gap_init()
{
     uint32_t err_code;
     ble_gap_conn_params_t gap_conn_params;
     ble_gap_conn_sec_mode_t sec_mode;

     // Open link, no encryption required on BLE layer. 
     // Security is handled only on the application layer. 
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&sec_mode);
     
     // Set device name.
     err_code = sd_ble_gap_device_name_set(&sec_mode,
					   (const uint8_t *) DEVICE_NAME,
					   strlen(DEVICE_NAME));
     if (err_code != NRF_SUCCESS)
	  die();
     
     // Set connection parameters.
     memset(&gap_conn_params, 0, sizeof(gap_conn_params));
     gap_conn_params.min_conn_interval = MIN_CONN_INTERVAL;
     gap_conn_params.max_conn_interval = MAX_CONN_INTERVAL;
     gap_conn_params.slave_latency = SLAVE_LATENCY;
     gap_conn_params.conn_sup_timeout = CONN_SUP_TIMEOUT;     
     err_code = sd_ble_gap_ppcp_set(&gap_conn_params);
     if (err_code != NRF_SUCCESS)
	  die();
}

static void add_characteristic_nonce(uint16_t service_handle)
{
     // Characteristic UUID.
     ble_uuid_t ble_uuid;
     ble_uuid.type = uuid_type;
     ble_uuid.uuid = UUID_CHARACTERISTIC_NONCE;

     // Define characteristic presentation format.
     // The nonce is a 16 byte number, which is declared as opaque struct.
     ble_gatts_char_pf_t char_presentation_format;
     memset(&char_presentation_format, 0, sizeof(char_presentation_format));
     char_presentation_format.format = BLE_GATT_CPF_FORMAT_STRUCT;
     char_presentation_format.exponent = 0;
     char_presentation_format.unit = 0x2700; // unitless

     // Define characteristic meta data.
     // The nonce is only readable.
     ble_gatts_char_md_t char_meta_data;
     memset(&char_meta_data, 0, sizeof(char_meta_data));
     char_meta_data.char_props.read = 1;
     char_meta_data.char_props.write = 0;
     char_meta_data.char_props.notify = 0;
     char_meta_data.char_props.indicate = 0;
     char_meta_data.p_char_user_desc = NULL;
     char_meta_data.p_char_pf = &char_presentation_format;
     char_meta_data.p_user_desc_md = NULL;
     // CCCD (Client Characteristic Configuration Descriptor) only needs to be 
     // set for characteristics allowing for notifications and indications.
     char_meta_data.p_cccd_md = NULL;
     char_meta_data.p_sccd_md = NULL;

     // Define attribute meta data. 
     ble_gatts_attr_md_t char_attr_meta_data;
     memset(&char_attr_meta_data, 0, sizeof(char_attr_meta_data));
     // No security needed. All security implemented on the application layer.
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&char_attr_meta_data.read_perm);
     BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&char_attr_meta_data.write_perm);
     // value location
     char_attr_meta_data.vloc = BLE_GATTS_VLOC_STACK;
     // always request read authorization from application 
     char_attr_meta_data.rd_auth = 0;
     // always request write authorization from application
     char_attr_meta_data.wr_auth = 0;
     // variable length attribute
     char_attr_meta_data.vlen = 0;

     // Define characteristic attributes. 
     // Nonce is a fixed length 16 byte data structure.
     ble_gatts_attr_t char_attributes;
     memset(&char_attributes, 0, sizeof(char_attributes));
     char_attributes.p_uuid = &ble_uuid;
     char_attributes.p_attr_md = &char_attr_meta_data;
     char_attributes.init_len = MAX_LENGTH_NONCE_CHAR;
     char_attributes.init_offs = 0;
     char_attributes.max_len = MAX_LENGTH_NONCE_CHAR;
     // For attributes managed by the application (BLE_GATTS_VLOC_USER)
     // rather than the BLE stack, set a pointer to the memory location here.
     char_attributes.p_value = NULL;

     // Add characteristic to service.
     if (sd_ble_gatts_characteristic_add(service_handle,
					 &char_meta_data,
					 &char_attributes,
					 &char_handle_nonce) != NRF_SUCCESS)
	  die();

     // Set initial characteristic value.
     ble_gatts_value_t value;
     memset(&value, 0, sizeof(value));
     value.len = sizeof(nonce);
     value.offset  = 0;
     value.p_value = nonce;
     if (sd_ble_gatts_value_set(BLE_CONN_HANDLE_INVALID, 
				char_handle_nonce.value_handle, &value) != 
	 NRF_SUCCESS)
	  die();
}

static void add_characteristic_unlock(uint16_t service_handle)
{
     // Characteristic UUID.
     ble_uuid_t ble_uuid;
     ble_uuid.type = uuid_type;
     ble_uuid.uuid = UUID_CHARACTERISTIC_UNLOCK;

     // Define characteristic presentation format.
     // This characteristic transports a 256 bit HMAC to authenticate the
     // door open request. 256 bit = 32 bytes are too long for a 
     // characteristic. So we split up the request into two 16 byte write
     // operations to the characteristic. Moreover, we include the key number
     // in the request as another byte. Thus, this is a 17 byte opaque
     // struct.
     ble_gatts_char_pf_t char_presentation_format;
     memset(&char_presentation_format, 0, sizeof(char_presentation_format));
     char_presentation_format.format = BLE_GATT_CPF_FORMAT_STRUCT;
     char_presentation_format.exponent = 0;
     char_presentation_format.unit = 0x2700; // unitless

     // Define characteristic meta data.
     // The Unlock characteristic must support writing to receive authentication
     // data.
     ble_gatts_char_md_t char_meta_data;
     memset(&char_meta_data, 0, sizeof(char_meta_data));
     char_meta_data.char_props.read = 1;
     char_meta_data.char_props.write = 1;
     char_meta_data.char_props.notify = 0;
     char_meta_data.char_props.indicate = 0;
     char_meta_data.p_char_user_desc = NULL;
     char_meta_data.p_char_pf = &char_presentation_format;
     char_meta_data.p_user_desc_md = NULL;
     // CCCD (Client Characteristic Configuration Descriptor) only needs to be 
     // set for characteristics allowing for notifications and indications.
     char_meta_data.p_cccd_md = NULL;
     char_meta_data.p_sccd_md = NULL;

     // Define attribute meta data. 
     ble_gatts_attr_md_t char_attr_meta_data;
     memset(&char_attr_meta_data, 0, sizeof(char_attr_meta_data));
     // No security needed. All security implemented on the application layer.
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&char_attr_meta_data.read_perm);
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&char_attr_meta_data.write_perm);
     // value location
     char_attr_meta_data.vloc = BLE_GATTS_VLOC_STACK;
     // always request read authorization from application 
     char_attr_meta_data.rd_auth = 0;
     // always request write authorization from application
     char_attr_meta_data.wr_auth = 0;
     // variable length attribute
     char_attr_meta_data.vlen = 0;

     // Define characteristic attributes. 
     // This is a fixed length 17 byte data structure.
     ble_gatts_attr_t char_attributes;
     memset(&char_attributes, 0, sizeof(char_attributes));
     char_attributes.p_uuid = &ble_uuid;
     char_attributes.p_attr_md = &char_attr_meta_data;
     char_attributes.init_len = MAX_LENGTH_UNLOCK_CHAR;
     char_attributes.init_offs = 0;
     char_attributes.max_len = MAX_LENGTH_UNLOCK_CHAR;
     // For attributes managed by the application (BLE_GATTS_VLOC_USER)
     // rather than the BLE stack, set a pointer to the memory location here.
     char_attributes.p_value = NULL;

     // Add characteristic to service.
     if (sd_ble_gatts_characteristic_add(service_handle,
					 &char_meta_data,
					 &char_attributes,
					 &char_handle_unlock) != NRF_SUCCESS)
	  die();
}

static void add_characteristic_cfg_in(uint16_t service_handle)
{
     // Characteristic UUID.
     ble_uuid_t ble_uuid;
     ble_uuid.type = uuid_type;
     ble_uuid.uuid = UUID_CHARACTERISTIC_CFG_IN;

     // Define characteristic presentation format.
     // This characteristic transports a 32 byte public key (split into two
     // 16 byte parts due to characteristic length restrictions) for
     // key exchange, plus one byte defining the key number.
     // Thus, this is a 17 byte opaque struct.
     ble_gatts_char_pf_t char_presentation_format;
     memset(&char_presentation_format, 0, sizeof(char_presentation_format));
     char_presentation_format.format = BLE_GATT_CPF_FORMAT_STRUCT;
     char_presentation_format.exponent = 0;
     char_presentation_format.unit = 0x2700; // unitless

     // Define characteristic meta data.
     // The config-in characteristic must support writing to receive
     // configuration data.
     ble_gatts_char_md_t char_meta_data;
     memset(&char_meta_data, 0, sizeof(char_meta_data));
     char_meta_data.char_props.read = 1;
     char_meta_data.char_props.write = 1;
     char_meta_data.char_props.notify = 0;
     char_meta_data.char_props.indicate = 0;
     char_meta_data.p_char_user_desc = NULL;
     char_meta_data.p_char_pf = &char_presentation_format;
     char_meta_data.p_user_desc_md = NULL;
     // CCCD (Client Characteristic Configuration Descriptor) only needs to be 
     // set for characteristics allowing for notifications and indications.
     char_meta_data.p_cccd_md = NULL;
     char_meta_data.p_sccd_md = NULL;

     // Define attribute meta data. 
     ble_gatts_attr_md_t char_attr_meta_data;
     memset(&char_attr_meta_data, 0, sizeof(char_attr_meta_data));
     // No security needed. All security implemented on the application layer.
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&char_attr_meta_data.read_perm);
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&char_attr_meta_data.write_perm);
     // value location
     char_attr_meta_data.vloc = BLE_GATTS_VLOC_STACK;
     // always request read authorization from application 
     char_attr_meta_data.rd_auth = 0;
     // always request write authorization from application
     char_attr_meta_data.wr_auth = 0;
     // variable length attribute
     char_attr_meta_data.vlen = 0;

     // Define characteristic attributes. 
     // This is a fixed length 17 byte data structure.
     ble_gatts_attr_t char_attributes;
     memset(&char_attributes, 0, sizeof(char_attributes));
     char_attributes.p_uuid = &ble_uuid;
     char_attributes.p_attr_md = &char_attr_meta_data;
     char_attributes.init_len = MAX_LENGTH_CFG_IN_CHAR;
     char_attributes.init_offs = 0;
     char_attributes.max_len = MAX_LENGTH_CFG_IN_CHAR;
     // For attributes managed by the application (BLE_GATTS_VLOC_USER)
     // rather than the BLE stack, set a pointer to the memory location here.
     char_attributes.p_value = NULL;

     // Add characteristic to service.
     if (sd_ble_gatts_characteristic_add(service_handle,
					 &char_meta_data,
					 &char_attributes,
					 &char_handle_cfg_in) != NRF_SUCCESS)
	  die();
}

static void add_characteristic_cfg_out(uint16_t service_handle)
{
     // Characteristic UUID.
     ble_uuid_t ble_uuid;
     ble_uuid.type = uuid_type;
     ble_uuid.uuid = UUID_CHARACTERISTIC_CFG_OUT;

     // Define characteristic presentation format.
     // This characteristic transports a 32 byte public key (split into two
     // 16 byte parts due to characteristic length restrictions) for
     // key exchange, plus one byte defining the key number.
     // Thus, this is a 17 byte opaque struct.
     ble_gatts_char_pf_t char_presentation_format;
     memset(&char_presentation_format, 0, sizeof(char_presentation_format));
     char_presentation_format.format = BLE_GATT_CPF_FORMAT_STRUCT;
     char_presentation_format.exponent = 0;
     char_presentation_format.unit = 0x2700; // unitless

     // Define CCCD attributes. 
     // CCCD (Client Characteristic Configuration Descriptor) is used by the
     // client to enable notifications or indications by writing a flag to the
     // CCCD attribute.
     ble_gatts_attr_md_t cccd_meta_data;
     memset(&cccd_meta_data, 0, sizeof(cccd_meta_data));
     // CCCD must be read and writable. 
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_meta_data.read_perm);
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_meta_data.write_perm);
     cccd_meta_data.vloc = BLE_GATTS_VLOC_STACK;

     // Define characteristic meta data.
     // The config-out characteristic must suppport indications for sending
     // config data to the client.
     ble_gatts_char_md_t char_meta_data;
     memset(&char_meta_data, 0, sizeof(char_meta_data));
     char_meta_data.char_props.read = 1;
     char_meta_data.char_props.write = 0;
     char_meta_data.char_props.notify = 0;
     char_meta_data.char_props.indicate = 1;
     char_meta_data.p_char_user_desc = NULL;
     char_meta_data.p_char_pf = &char_presentation_format;
     char_meta_data.p_user_desc_md = NULL;
     // CCCD (Client Characteristic Configuration Descriptor) needs to be 
     // set for characteristics allowing for notifications and indications.
     char_meta_data.p_cccd_md = &cccd_meta_data;
     char_meta_data.p_sccd_md = NULL;

     // Define attribute meta data. 
     ble_gatts_attr_md_t char_attr_meta_data;
     memset(&char_attr_meta_data, 0, sizeof(char_attr_meta_data));
     // No security needed. All security implemented on the application layer.
     BLE_GAP_CONN_SEC_MODE_SET_OPEN(&char_attr_meta_data.read_perm);
     BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&char_attr_meta_data.write_perm);
     // value location
     char_attr_meta_data.vloc = BLE_GATTS_VLOC_STACK;
     // always request read authorization from application 
     char_attr_meta_data.rd_auth = 0;
     // always request write authorization from application
     char_attr_meta_data.wr_auth = 0;
     // variable length attribute
     char_attr_meta_data.vlen = 0;

     // Define characteristic attributes. 
     // This is a fixed length 17 byte data structure.
     ble_gatts_attr_t char_attributes;
     memset(&char_attributes, 0, sizeof(char_attributes));
     char_attributes.p_uuid = &ble_uuid;
     char_attributes.p_attr_md = &char_attr_meta_data;
     char_attributes.init_len = MAX_LENGTH_CFG_OUT_CHAR;
     char_attributes.init_offs = 0;
     char_attributes.max_len = MAX_LENGTH_CFG_OUT_CHAR;
     // For attributes managed by the application (BLE_GATTS_VLOC_USER)
     // rather than the BLE stack, set a pointer to the memory location here.
     char_attributes.p_value = NULL;

     // Add characteristic to service.
     if (sd_ble_gatts_characteristic_add(service_handle,
					 &char_meta_data,
					 &char_attributes,
					 &char_handle_cfg_out) != NRF_SUCCESS)
	  die();
}

static void service_init()
{
     uint32_t err_code;
     
     // Add base UUID to list of base UUIDs.
     // The uuid_type field filled by this function call can be used later to
     // refer to this base UUID.
     ble_uuid128_t base_uuid = {UUID_BASE};
     err_code = sd_ble_uuid_vs_add(&base_uuid, &uuid_type);
     if (err_code != NRF_SUCCESS)
	  die();

     // Build 128 bit service UUID by referring to base UUID using uuid_type
     // and specifying the two bytes that will replace byte 12 and 13 of the
     // base UUID. 
     ble_uuid_t ble_uuid;
     ble_uuid.type = uuid_type;
     ble_uuid.uuid = UUID_SERVICE;
     
     err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, 
					 &ble_uuid, &service_handle);
     if (err_code != NRF_SUCCESS)
	  die();
     
     // Add characteristics to service.
     add_characteristic_nonce(service_handle);
     add_characteristic_unlock(service_handle);
     add_characteristic_cfg_in(service_handle);
     add_characteristic_cfg_out(service_handle);
}

/*
static void conn_params_error_handler(uint32_t nrf_error)
{
}

static void on_conn_params_evt(ble_conn_params_evt_t * p_evt)
{
    uint32_t err_code;

    if (p_evt->evt_type == BLE_CONN_PARAMS_EVT_FAILED)
    {
        err_code = sd_ble_gap_disconnect(m_conn_handle, 
					 BLE_HCI_CONN_INTERVAL_UNACCEPTABLE);
        APP_ERROR_CHECK(err_code);
    }
}

static void conn_params_init()
{
    uint32_t err_code;
    ble_conn_params_init_t cp_init;

    memset(&cp_init, 0, sizeof(cp_init));
    cp_init.p_conn_params = NULL;
    cp_init.first_conn_params_update_delay = FIRST_CONN_PARAMS_UPDATE_DELAY;
    cp_init.next_conn_params_update_delay  = NEXT_CONN_PARAMS_UPDATE_DELAY;
    cp_init.max_conn_params_update_count = MAX_CONN_PARAMS_UPDATE_COUNT;
    cp_init.start_on_notify_cccd_handle = BLE_GATT_HANDLE_INVALID;
    cp_init.disconnect_on_fail = true;
    cp_init.evt_handler = on_conn_params_evt;
    cp_init.error_handler = conn_params_error_handler;

    err_code = ble_conn_params_init(&cp_init);
    if (err_code != NRF_SUCCESS)
	 die();
}
*/

static void advertising_init(void)
{
     ble_uuid_t adv_uuids[] = {{UUID_SERVICE, uuid_type}};
     
     ble_advdata_t advdata;
     memset(&advdata, 0, sizeof(advdata));
     advdata.name_type = BLE_ADVDATA_FULL_NAME;
     advdata.include_appearance = false;
     // LE General Discoverable Mode.
     advdata.flags = BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE;
     // Send complete set of UUIDs.
     advdata.uuids_complete.uuid_cnt = sizeof(adv_uuids)/sizeof(adv_uuids[0]);
     advdata.uuids_complete.p_uuids = adv_uuids;
     
     // No scan response data needs to be defined since everything fits into 
     // the advertisement message (the scan response can be requested by the 
     // central device to get more information from the peripheral).
     if (ble_advdata_set(&advdata, NULL) != NRF_SUCCESS)
	  die();
}

static void config_timer_evt_handler(void *p_context)
{
     UNUSED_PARAMETER(p_context);
     struct app_event app_event = {.event_type = APP_EVENT_CFG_TIMEOUT};
     app_event_queue_add(&app_event_queue, app_event);
}

static void timers_init()
{
     // Initialize application timer using RTC1 (RTC0 is used by the
     // BLE softdevice).
     APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_QUEUE_SIZE, false);

     if (app_timer_create(&config_timer, APP_TIMER_MODE_SINGLE_SHOT,
			  config_timer_evt_handler) != NRF_SUCCESS)
	  die();
}

static void start_config_timer()
{
     // Only start timer once (actually, app_timer_start() will anyway
     // ignore starting an already running timer).
     if (is_config_timer_active)
	  return;

     if (app_timer_start(config_timer, CONFIG_TIMER_TIMEOUT, NULL) !=
	 NRF_SUCCESS)
	  die();

     is_config_timer_active = true;
}

static void stop_config_timer()
{
     app_timer_stop(config_timer);
     is_config_timer_active = false;
}

static void button_evt_handler(uint8_t pin_no, uint8_t button_action)
{
     struct app_event app_event;

     switch (pin_no) {
     case PIN_BUTTON1 :
	  if (APP_BUTTON_PUSH == button_action) {
	       app_event.event_type = APP_EVENT_BUTTON1_PRESSED;
	       app_event_queue_add(&app_event_queue, app_event);
	  }
	  break;
     }
}

static void buttons_init()
{
     // Switch connects pin to GND (active low) -> second parameter = false.
     // Enable internal pull up -> NRF_GPIO_PIN_PULLUP.
     static app_button_cfg_t buttons[] = {
	  {PIN_BUTTON1, false, NRF_GPIO_PIN_PULLUP, button_evt_handler}
     };

     if (app_button_init(buttons, sizeof(buttons) / sizeof(buttons[0]),
			 BUTTON_DETECTION_DELAY) != NRF_SUCCESS)
	  die();
}

static void start_button_event_detection()
{
     if (app_button_enable() != NRF_SUCCESS)
	  die();
}

static void create_nonce()
{
     uint8_t available;
     unsigned int remaining = NONCE_LENGTH;
     unsigned int offset = 0;
     while (remaining > 0) {
	  if (sd_rand_application_bytes_available_get(&available) != NRF_SUCCESS)
	       die();
	  uint8_t length = (remaining < available) ? remaining : available;
	  if (sd_rand_application_vector_get(&nonce[offset], length) != 
	      NRF_SUCCESS)
	       die();
	  remaining -= length;
	  offset += length;
     }
}

static void ecdh_secret_key(uint8_t secret_key[ECDH_KEY_LENGTH])
{
    uint8_t available;
    unsigned int remaining = ECDH_KEY_LENGTH;
    unsigned int offset = 0;
    while (remaining > 0) {
	 if (sd_rand_application_bytes_available_get(&available) != NRF_SUCCESS)
	      die();
	 uint8_t length = (remaining < available) ? remaining : available;
	 if (sd_rand_application_vector_get(&secret_key[offset], length) != 
	     NRF_SUCCESS)
	      die();
	 remaining -= length;
	 offset += length;
    }

    // We need to clear bits 0-2 and set bit 254 to prevent small-subgroup 
    // attacks and timing attacks, respectively:
    // http://crypto.stackexchange.com/questions/12425/why-are-the-lower-3-bits-of-curve25519-ed25519-secret-keys-cleared-during-creati/12614)
    secret_key[0] &= 248;
    secret_key[ECDH_KEY_LENGTH-1] &= 127;
    secret_key[ECDH_KEY_LENGTH-1] |= 64;
}

void ecdh_public_key(uint8_t public_key[ECDH_KEY_LENGTH], 
		     const uint8_t secret_key[ECDH_KEY_LENGTH])
{
     // In the following call, base is 9.
     crypto_scalarmult_curve25519_base(public_key, secret_key);
}

void ecdh_shared_secret(uint8_t shared_secret[ECDH_KEY_LENGTH],
			const uint8_t my_secret_key[ECDH_KEY_LENGTH],
			const uint8_t other_public_key[ECDH_KEY_LENGTH])
{
     crypto_scalarmult_curve25519(shared_secret, my_secret_key, 
				  other_public_key);
}

static void display_init()
{
     hd44780_init(&lcd);
}

static void display_on()
{
     hd44780_display_on_off(&lcd, true, false, false);
}

static void display_off()
{
     hd44780_display_on_off(&lcd, false, false, false);
}

static void display_text(const char *text1, unsigned int length1,
			 const char *text2, unsigned int length2)
{
     hd44780_clear_display(&lcd);
     if (text1 != NULL)
	  hd44780_print_line(&lcd, text1, length1, 0);
     if (text2 != NULL)
	  hd44780_print_line(&lcd, text2, length2, 1);
}

static void nonce_init()
{
     create_nonce();
}

static void state_transition(struct app_event event) 
{
     switch (app_state) {
     case idle :
	  if (event.event_type == APP_EVENT_BUTTON1_PRESSED)
	       app_state = cfg_wait_connection;
	  if (event.event_type == APP_EVENT_CLIENT_CONNECTED)
	       app_state = wait_hmac_part1;
	  break;
     case cfg_wait_connection :

	  break;

     case cfg_wait_subscription :

	  break;
     case cfg_wait_key_part1 :
	  
	  break;
     case cfg_wait_key_part2 : 

	  break;

     case cfg_wait_ack :

	  break;
     case cfg_wait_confirmation :

	  break;
     case wait_hmac_part1 :

	  break;
     case wait_hmac_part2 :

	  break;
     }
}

int main(void)
{
     led_init();

     display_init();
     display_on();
     display_text("Booting ...", 11, NULL, 0);

     init_app_event_queue();

     timers_init();
     buttons_init();
     ble_stack_init();
     nonce_init();
     gap_init();
     service_init();
     advertising_init();
	  
     //conn_params_init();

     /*
     uint8_t secret_key[ECDH_KEY_LENGTH];
     uint8_t public_key[ECDH_KEY_LENGTH];
     ecdh_secret_key(secret_key);
     ecdh_public_key(public_key, secret_key);

     uint8_t hash[SHA512_HASH_LENGTH];
     led_on();
     crypto_hash_sha512(hash, secret_key, sizeof(secret_key));
     led_off();
     */

     start_button_event_detection();
     start_advertising();
     
     display_text("Ready", 5, NULL, 0);

     while (1) {
	  // The following function puts the processor into sleep mode
	  // and waits for interrupts to wake up. Wakeup events include
	  // events from the softdevice, which are processed in the BLE event 
	  // loop, or other events like interrupts from application timers and
	  // pressed buttons.
	  sd_app_evt_wait();

	  struct app_event app_event;
	  while (app_event_queue_get(&app_event_queue, &app_event) != -1)
	       state_transition(app_event);
     }
}
